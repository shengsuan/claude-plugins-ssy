---
name: go-zero-framework
description: This skill should be used when working with go-zero microservices framework, when the user asks to "create a go-zero API service", "build a gRPC service with go-zero", "generate go-zero models", "implement REST API with go-zero", "add authentication to go-zero", "configure circuit breaker", "troubleshoot go-zero issues", or mentions go-zero, goctl, Handler/Logic/Model architecture, or microservices development patterns.
version: 1.0.0
---

# go-zero Framework Development

Comprehensive knowledge base for building production-ready microservices with the go-zero framework.

## Overview

go-zero is a web and RPC framework with built-in engineering practices for building resilient microservices. This skill provides patterns, best practices, and workflows for go-zero development, covering REST APIs, gRPC services, database operations, and resilience patterns.

**Core capabilities:**
- REST API development with three-layer architecture
- gRPC service implementation with service discovery
- Database operations with caching strategies
- Resilience patterns (circuit breaker, rate limiting, load shedding)
- Production-ready configuration and deployment

## When to Use This Skill

Use this skill when:
- Creating new go-zero API or RPC services
- Implementing Handler/Logic/Model architecture
- Integrating databases (MySQL, PostgreSQL, MongoDB, Redis)
- Adding authentication, validation, or middleware
- Troubleshooting go-zero applications
- Applying microservices best practices

## Quick Start Guide

### Creating a New API Service

Follow the spec-first workflow:

1. **Create API specification** using `create_api_spec` MCP tool
2. **Validate specification** with `validate_input` tool
3. **Generate service structure** using `create_api_service` tool
4. **Generate code from spec** with `generate_api_from_spec` tool
5. **Implement business logic** in the Logic layer
6. **Add validation** with validate tags
7. **Generate tests** for all handlers
8. **Create documentation** (README.md with API examples)

### Creating a New RPC Service

Follow the protobuf-first workflow:

1. **Create RPC service** using `create_rpc_service` MCP tool
2. **Define protobuf** schema (.proto file)
3. **Implement methods** in the Logic layer
4. **Add service discovery** configuration
5. **Generate tests** for all methods
6. **Create documentation** (README.md with gRPC examples)

### Adding Database Models

1. **Determine database type** (MySQL, PostgreSQL, MongoDB)
2. **Generate model** using `generate_model` MCP tool with caching if needed
3. **Inject model** into ServiceContext
4. **Use model** in Logic layer with proper error handling

## Core Architecture

### Three-Layer Architecture

go-zero enforces clean architecture with three distinct layers:

```
Request → Handler → Logic → Model → Database
                      ↓
                   Response
```

**Handler Layer** (`internal/handler/`):
- Receives HTTP requests
- Extracts and validates path/query parameters
- Delegates to Logic layer
- Returns formatted responses

**Logic Layer** (`internal/logic/`):
- Contains all business logic
- Validates request data
- Orchestrates database operations
- Handles errors with proper status codes
- Returns structured responses

**Model Layer** (`internal/model/`):
- Database access only
- Generated by goctl from database schema
- Provides CRUD operations
- Handles caching transparently

**Critical rules:**
- Handler NEVER contains business logic
- Logic NEVER does direct database access
- Model NEVER contains business logic
- Always pass context through all layers

### Service Context

ServiceContext wires dependencies for injection:

```go
type ServiceContext struct {
    Config    config.Config
    UserModel model.UserModel
    Validator *validator.Validate
}

func NewServiceContext(c config.Config) *ServiceContext {
    conn := sqlx.NewMysql(c.MySQL.DataSource)
    return &ServiceContext{
        Config:    c,
        UserModel: model.NewUserModel(conn, c.Cache),
        Validator: validator.New(),
    }
}
```

Inject models, validators, and external clients through ServiceContext.

## Development Workflows

### Workflow 1: New API Service with Database

1. Ask user for requirements (entities, endpoints, database)
2. Use `create_api_spec` to generate .api specification
3. Show specification to user for approval
4. Use `create_api_service` to create service structure
5. Use `generate_model` to create database models
6. Use `generate_api_from_spec` to generate handlers/logic
7. Implement business logic in Logic layer
8. Add validation tags to request types
9. Generate comprehensive tests
10. Create README.md with API documentation and curl examples

### Workflow 2: Add Authentication to API

1. Add JWT configuration to config struct
2. Create login endpoint that generates JWT token
3. Add `@server(jwt: Auth)` to protected routes in .api
4. Regenerate code with `generate_api_from_spec`
5. Access userId from context in protected handlers
6. Update tests for authenticated endpoints
7. Document authentication flow in README.md

### Workflow 3: Add Caching

1. Add cache configuration to config struct
2. Regenerate model with `cache=true` using `generate_model`
3. Configure cache in etc/config.yaml
4. Model automatically uses cache for queries
5. Test cache behavior with repeated queries

### Workflow 4: Modify Existing API

1. Edit .api file with new endpoints or types
2. Use `validate_input` to check syntax
3. Use `generate_api_from_spec` (safe to re-run)
4. Implement new logic in generated Logic files
5. Update tests for new/modified endpoints
6. Update API documentation

## Essential Patterns

### API Specification Patterns

**Basic endpoint:**
```api
type CreateUserRequest {
    Email string `json:"email" validate:"required,email"`
    Name  string `json:"name" validate:"required,min=2"`
}

type CreateUserResponse {
    Id    int64  `json:"id"`
    Email string `json:"email"`
}

@server(group: user)
service user-api {
    @handler createUser
    post /api/users (CreateUserRequest) returns (CreateUserResponse)
}
```

**JWT protected endpoint:**
```api
@server(
    jwt: Auth
    group: user
)
service user-api {
    @handler getUserProfile
    get /api/users/profile returns (UserProfileResponse)
}
```

**Path parameters:**
```api
type GetUserRequest {
    Id int64 `path:"id"`
}

@server(group: user)
service user-api {
    @handler getUser
    get /api/users/:id (GetUserRequest) returns (UserResponse)
}
```

### Logic Implementation Patterns

**Standard logic with validation:**
```go
func (l *CreateUserLogic) CreateUser(req *types.CreateUserRequest) (*types.CreateUserResponse, error) {
    // Validate input
    if err := l.svcCtx.Validator.StructCtx(l.ctx, req); err != nil {
        return nil, errorx.NewCodeError(400, err.Error())
    }

    // Business logic
    user := &model.User{
        Email: req.Email,
        Name:  req.Name,
    }

    result, err := l.svcCtx.UserModel.Insert(l.ctx, user)
    if err != nil {
        return nil, errorx.NewCodeError(500, "failed to create user")
    }

    id, _ := result.LastInsertId()
    return &types.CreateUserResponse{
        Id:    id,
        Email: user.Email,
    }, nil
}
```

**Error handling:**
```go
// Use errorx.NewCodeError for HTTP errors
if err == model.ErrNotFound {
    return nil, errorx.NewCodeError(404, "user not found")
}
if err != nil {
    return nil, errorx.NewCodeError(500, "internal error")
}
```

### Configuration Patterns

**Config struct:**
```go
type Config struct {
    rest.RestConf
    MySQL struct {
        DataSource string
    }
    Auth struct {
        AccessSecret string
        AccessExpire int64
    }
    Cache cache.CacheConf
}
```

**YAML configuration:**
```yaml
Name: user-api
Port: 8888
MySQL:
  DataSource: user:pass@tcp(localhost:3306)/db
Auth:
  AccessSecret: your-secret-key
  AccessExpire: 86400
Cache:
  - Host: localhost:6379
```

### Validation Patterns

Add validation tags to types:
```go
type CreateRequest struct {
    Email    string `validate:"required,email"`
    Password string `validate:"required,min=8"`
    Age      int    `validate:"min=18,max=100"`
    Website  string `validate:"url"`
}
```

Common tags: `required`, `email`, `min=X`, `max=X`, `len=X`, `oneof=a b`, `url`, `uuid`

## Key Principles

### Always Follow

✅ **Three-layer separation**: Handler → Logic → Model architecture
✅ **Spec-first development**: Create .api before generating code
✅ **Structured errors**: Use `errorx.NewCodeError(code, msg)` for HTTP errors
✅ **Context propagation**: Pass `ctx` through all function calls
✅ **Type safety**: Define all types in .api files, generate with goctl
✅ **Validation**: Use validate tags and Validator in ServiceContext
✅ **Configuration**: Load config with `conf.MustLoad`, never hardcode values
✅ **Full implementation**: Generate complete business logic, not empty stubs
✅ **Documentation**: Always generate README.md with API examples and testing instructions

### Never Do

❌ **Business logic in handlers**: Handlers only route requests
❌ **Direct database access in logic**: Always use Model layer
❌ **fmt.Errorf for API errors**: Use errorx.NewCodeError instead
❌ **Hardcoded configuration**: Use config structs and YAML files
❌ **Skip validation**: Always validate user input
❌ **Ignore errors**: Handle all errors appropriately
❌ **Empty stubs**: Implement full logic, not placeholder code
❌ **Missing documentation**: Generate comprehensive README.md with usage examples

## MCP Tools Reference

Use these MCP tools (provided by mcp-zero server) for code generation:

**Service creation:**
- `create_api_service`: Create new REST API service structure
- `create_rpc_service`: Create new gRPC service structure
- `create_api_spec`: Generate API specification from description

**Code generation:**
- `generate_api_from_spec`: Generate Go code from .api file (safe to re-run)
- `generate_model`: Generate database models with optional caching
- `generate_template`: Generate middleware, error handlers, deployment templates

**Validation:**
- `validate_input`: Validate .api file syntax
- `validate_config`: Validate configuration file

**Project management:**
- `analyze_project`: Analyze existing go-zero project structure
- `generate_config_template`: Generate configuration templates

Always use MCP tools instead of manual goctl commands for consistency.

## Additional Resources

### Reference Files

For detailed patterns and implementation guides, consult:

- **`references/rest-api-patterns.md`** - Complete REST API development patterns with ✅ correct and ❌ incorrect examples
- **`references/rpc-patterns.md`** - gRPC service patterns, service discovery, and load balancing
- **`references/database-patterns.md`** - Database operations, caching strategies, and connection pooling
- **`references/resilience-patterns.md`** - Circuit breaker, rate limiting, and graceful degradation
- **`references/best-practices.md`** - Production deployment and configuration
- **`references/troubleshooting.md`** - Common issues and solutions
- **`references/workflows.md`** - Detailed workflow guides for common tasks

### Example Files

Working examples available in `examples/`:

- **`examples/demo-project/`** - Complete demo project structure
- **`examples/verify-tutorial.sh`** - Script to verify go-zero setup

### External Resources

- Official documentation: https://go-zero.dev
- GitHub repository: https://github.com/zeromicro/go-zero
- Community support available in go-zero developer community

## Progressive Learning Path

**New to go-zero:**
1. Start with Quick Start Guide above
2. Create a simple REST API following Workflow 1
3. Study `references/rest-api-patterns.md` for detailed patterns
4. Add database operations using `references/database-patterns.md`

**Building production services:**
1. Review `references/best-practices.md` for deployment guidance
2. Implement resilience patterns from `references/resilience-patterns.md`
3. Reference `references/troubleshooting.md` for common pitfalls

**Advanced topics:**
1. Study `references/rpc-patterns.md` for microservices communication
2. Implement service discovery and load balancing
3. Use demo project in `examples/demo-project/` as reference

## Common Decision Matrix

| User Request | Primary Workflow | Key Tools |
|--------------|------------------|-----------|
| Create API service | Workflow 1 | create_api_spec, create_api_service, generate_api_from_spec |
| Add database | Workflow 3 | generate_model |
| Protect endpoint | Workflow 2 | Edit .api, add JWT config |
| Modify API | Workflow 4 | validate_input, generate_api_from_spec |
| Create RPC service | Workflow 2 | create_rpc_service |
| Troubleshoot issue | Reference troubleshooting.md | analyze_project |

## Code Generation Rules

When generating go-zero code:

1. **Always create complete implementations**, not empty stubs
2. **Add validation tags** to all request types
3. **Use errorx.NewCodeError** for all HTTP error responses
4. **Pass context** as first parameter to all functions
5. **Generate comprehensive tests** with table-driven test patterns
6. **Generate README.md** including:
   - Service overview and purpose
   - API endpoint documentation with request/response examples
   - Configuration guide
   - Usage examples with curl commands
   - Testing instructions
   - Error codes and handling
7. **Follow naming conventions**: Handler/Logic/Model naming patterns
8. **Include error codes documentation** in README.md
9. **Provide testing examples** for all endpoints

## Version Compatibility

This skill targets go-zero 1.5+. Patterns reflect current framework conventions. Always verify with official documentation for the latest API changes.
